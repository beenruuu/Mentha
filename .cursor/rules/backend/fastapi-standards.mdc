---
description: FastAPI Backend Development Standards and Patterns
globs: ["backend/**/*.py"]
alwaysApply: false
---

# FastAPI Backend Standards

## Architecture Philosophy: When is a Backend Justified?

> **A separate backend only makes sense for tasks that CAN'T run in Next.js serverless/edge.**

### This backend exists because:
| Task | Why it needs a separate server |
|------|-------------------------------|
| **AI Model Queries** | Long-running, async (OpenAI, Claude, Perplexity) |
| **Web Scraping** | Firecrawl jobs can take 30+ seconds |
| **Background Analysis** | Heavy computation, can't block render |
| **Rate Limiting** | Centralized API key management |

### What should NOT go in backend:
- Simple CRUD → Use Next.js + Supabase directly
- User authentication → Already in Supabase + Next.js
- Static data → Cache in Next.js/CDN

### Latency consideration:
```
With backend:    User → CDN → Next.js → FastAPI → Supabase (4 hops)
Without backend: User → CDN → Next.js → Supabase (3 hops)
```

**Rule:** If an endpoint just wraps Supabase with no extra logic, move it to Next.js Server Actions.

---

## API Endpoint Structure

Follow this pattern for all API endpoints:

```python
from fastapi import APIRouter, Depends, HTTPException
from app.models.auth import User
from app.services.supabase.auth import get_current_user

router = APIRouter()

@router.post("/endpoint", response_model=ResponseModel)
async def endpoint_name(
    request: RequestModel,
    current_user: User = Depends(get_current_user)
) -> ResponseModel:
    try:
        # Business logic here
        result = await service.method(request.data)
        return ResponseModel(**result)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

## Service Layer Pattern

All external service interactions must go through service classes:

- Use `SupabaseDatabaseService` for database operations
- Use `SupabaseStorageService` for file operations
- Use `LLMService` for text generation
- Use `EmbeddingService` for vector embeddings
- Use `QdrantService` for vector database operations

## Error Handling

Always use proper HTTP status codes and descriptive error messages:

```python
from fastapi import HTTPException

# Bad
raise Exception("Something went wrong")

# Good
raise HTTPException(
    status_code=404,
    detail="Resource not found with the provided ID"
)
```

## Authentication

All protected endpoints must use the authentication dependency:

```python
from app.services.supabase.auth import get_current_user

@router.get("/protected")
async def protected_endpoint(current_user: User = Depends(get_current_user)):
    # Endpoint logic
```

## Configuration

Use the centralized config system:

```python
from app.core.config import settings

# Access environment variables through settings
supabase_url = settings.SUPABASE_URL
```

## Async/Await

Always use async/await for I/O operations:

```python
# Database operations
result = await database_service.create(data)

# External API calls
response = await llm_service.generate(prompt)
```